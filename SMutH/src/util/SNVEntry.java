/**
 * Class: VCFEntry
 * Constructor: VCFEntry(String entry)
 * ----
 * This class represents a particular VCF entry from a 
 * VCF file. Note that all samples are 0-indexed.
 */
package util;


public abstract class  SNVEntry {
	
		
	/* Instance Variables */
	 protected String row;

	 protected String chrom;
	 protected int pos;
	 protected char ref;
	 protected char alt;	
		
	 protected String[] genotype;
	 protected boolean robust;
	
	public String getChromosome(){
		return chrom;
	}
	
	public int getChromNum(){
		if (chrom.charAt(3) == 'X') return 23;
		if (chrom.charAt(3) == 'Y') return 24;
		return new Integer(chrom.substring(3)).intValue();
	}
	
	
	/**
	 * Function: getPosition()
	 * Usage: String pos = entry.getPos()
	 * ----
	 * Returns the position of the entry as a string
	 * @return
	 */
	public int getPosition(){
		return pos;
	}
	
	/**
	 * Function: getRefChar()
	 * Usage: char ref = entry.getRefChar()
	 * ----
	 * Returns the reference allele of the entry
	 * 
	 * @return the reference allele as a char
	 */
	public char getRefChar(){
		return ref;
	}
	
	/**
	 * Function: getAltChar()
	 * Usage: char alt = entry.getAltChar()
	 * ----
	 * Returns the alternate allele of the entry
	 * 
	 * @return the alternate allele as a char
	 */
	public char getAltChar(){
		return alt;
	}
	
	
	/**
	 * Function: getGenotype(int sample)
	 * Usage: String genotype = entry.getGenotype(sample)
	 * ----
	 * Returns the particular genotype of a sample from the entry.
	 * The genotype is generated by GATK.
	 * @param sample	the particular sample from the entry
	 * @return	the genotype of the sample of the entry as a string
	 */
	public String getGenotype(int sample){
		return genotype[sample];
	}
	
	public boolean isRobust(){
		return robust;
	}
	/**
	 * Function: getGATK(int sample)
	 * Usage: String gatk = entry.getGATK(sample)
	 * ----
	 * Returns the GATK code for a sample. The GATK code is
	 * found by checking whether the genotype is equivalent to "0/0"
	 * for each sample. If so, 0 is appended as the GATK code
	 * for that sample; otherwise, 1 is appended. At the end,
	 * one will have a binary code of length equal to the number of 
	 * samples for the entry.
	 * @return	The GATK code for an entry as a string
	 */
	public String getGroup(){
		String result = "";
		for (int i = 0; i < genotype.length; i++){
			if (genotype[i].equals("0/0")) result += "0";
			else result += "1";
			//System.out.println(result);
		}
		return result;
	}
	
	public abstract void updateGroup(String code);

	
	public abstract double getAAF(int i) ;
	
	
	/**
	 * Function: isConvertable(int sample)
	 * Usage: Boolean = entry.isConvertable(sample)
	 * ----
	 * Returns true if there is evidence of presence for the mutation. 
	 * If so the genotype can be changed.
	 * @return	ture if the genotype for sample can be changed.
	 */
	public abstract boolean EvidenceOfPresence(int sample);
	public abstract boolean EvidenceOfAbsence(int sample);

	
	/**
	 * Function: getProb(int sample, int d, int k)
	 * Usage: double prob = entry.getProb(sample, d, k)
	 * ----
	 * This function calculates the probability of a sample
	 * being called incorrectly. Is used by getSumProb (which
	 * acts as a wrapper).
	 * 
	 * @param sample	The particular sample of the entry
	 * @param d			The allele depth of the sample
	 * @param k			The minor allele count
	 * @return	The probability as a double
	 */
	protected double getProb(int sample, int d, int k){
		return nCr(d, k) * Math.pow(Configs.BASE_ERROR / 3.0, k) * Math.pow((1 - Configs.BASE_ERROR), d - k);
	}
	
	/**
	 * Function: nCr(int n, int k)
	 * Usage: double result = entry.nCr(n, k)
	 * ----
	 * This calculates the result of "n choose k". In other words, 
	 * it returns the number of combinations to choose k from 
	 * n objects.
	 * @param n	The number of total objects
	 * @param k	How many objects chosen
	 * @return	n choose k as a double
	 */
	protected double nCr(int n, int k) {
	    if (k < 0 || k > n) return 0;
	    if (k > n/2) k = n - k;
	    double denominator = 1.0, numerator = 1.0;
	    for (int i = 1; i <= k; i++) {
	        denominator *= i;
	        numerator *= (n + 1 - i);
	    }
	    return numerator / denominator;
	}
	
	public String toString(){
		return row;
	}
}
